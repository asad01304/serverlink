#!/bin/bash

# Options:
# -P -- save shadow entry

error()
{
  echo "ERROR${1+: }$@" >&2
  exit 1
}

usage() {
  local prog=$(basename "$0")

  echo "Usage: $prog [options] <vhost> [archive_name]

  Options:
    -P        save shadow entry
    -d        debug mode: prints more verbose debug msgs, and doesn't remove
              the temporary directory on exit

  This command creates an archive of the current state of a vhost, saving
  Apache files and MySQL databases into a tar ball.
"
  exit 1
}

cleanup()
{
  unlock_path "$vhost_archive_dir"

  if [ -z "$debug" -a -n "$tmp_archive_dir" -a -d "$tmp_archive_dir" ]; then
    rm_rf_safer "$tmp_archive_dir"
  elif [ -n "$debug" ]; then
    echo "Kept temporary directory at $tmp_archive_dir" 1>&2
  fi
}

run()
{
  echo "  Running $@"
  "$@"
}

# main

[ $# -eq 0 -o -z "$1" ] && usage

exec 3>&1
exec 1>&2

archive_vhost_web_options=""
check_archive_pathname_options=""
debug=""

while getopts "Pud" OPTOPT
do
  case "$OPTOPT" in
    P) archive_vhost_web_options="${archive_vhost_web_options+ }-P";;
    u) : ;; # removed, kept here meanwhile all references are not removed
    d) debug=1 ;;
    *) exit 1;
  esac
done
[ $OPTIND -gt 1 ] && shift `expr $OPTIND - 1`

[ $# -eq 0 -o -z "$1" ] && usage

self_bin=$(readlink -e "$0")
dir=`dirname "$self_bin"`
sys_dir=$(readlink -e "$dir/..")

lib_file="$sys_dir/lib/functions"
if ! source "$lib_file"; then
  echo "Error: unable to load lib file '$lib_file'" 1>&2
  exit 1
fi

vhost="$1"
archive_to="$2"

user_db="b_$vhost"
user_web="w_$vhost"

$dir/check-vhost-name archive "$vhost" || usage
home="`eval echo -n \~$user_web`"
[ -d "$home" ] || error "Home dir $home does not exist"

assign_deref_os_prop_or_exit sys_data_dir "$sys_dir" data_dir
sys_data_dir=$(readlink -e "$sys_data_dir")
if [ $? -ne 0 ]; then
  if   [ ! -e "$sys_data_dir" ]; then
    error "missing system data directory $sys_data_dir"
  elif [ ! -d "$sys_data_dir" ]; then
    error "path '$sys_data_dir' is not a directory."
  else
    error "unknown error on path $sys_data_dir"
  fi
fi

assign_deref_os_prop_or_exit archive_template_str "$sys_dir" \
  vhost_archive_template_str

sys_archive_dir="$sys_data_dir/vhost_archives"

# create sys_archive_dir if it doesn't exist
if [ $? -ne 0 -o -z "$sys_archive_dir" ]; then
  mkdir -m 711 "$sys_archive_dir"
  if [ $? -ne 0 ]; then
    error "unable to create archive directory '$sys_archive_dir'"
  fi
fi
vhost_archive_dir="$sys_archive_dir/$vhost"

if [ -n "$archive_to" ]; then
  if [ "${archive_to:0:1}" == "/" ]; then
    tmp_full_path="$archive_to"
  else
    tmp_full_path="$vhost_archive_dir/$archive_to"
  fi

  tmp_to_file=$(readlink -m "$tmp_full_path")
  vhost_archive_dir_len=${#vhost_archive_dir}

  # compare the full path name of $tmp_to_file with $sys_archive_dir
  if [ ${#tmp_to_file} -le $vhost_archive_dir_len -o \
    "${tmp_to_file:0:$vhost_archive_dir_len}" != "$vhost_archive_dir" ]; then
    error "the file needs to created inside $vhost_archive_dir. Please don't\
 use a path with the filename".
  fi

  archive_filename=$(basename "$archive_to")
else
  # archive name was not passed on cmdline, use the full template
  archive_filename="$archive_template_str"
fi

# do some last transformations to the archive_filename
archive_filename=${archive_filename//@archive_template_str@/"$archive_template_str"}
archive_filename=${archive_filename//@vhost@/"$vhost"}
archive_filename=$(date_placeholders "$archive_filename")
[ $? -ne 0 ] && exit 1

target_file="$vhost_archive_dir/$archive_filename"
if ! [[ "$target_file" =~ \.[Tt][Gg][Zz]$ ]]; then
  target_file+=".tgz"
fi

if [ -e "$target_file" -o -L "$target_file" ]; then
  error "file '$target_file' already exists."
fi

# create vhost_archive_dir if it doesn't exist
if [ ! -d "$vhost_archive_dir" ]; then
  mkdir -m 2750 "$vhost_archive_dir"
  if [ $? -ne 0 ]; then
    error "unable to create directory '$vhost_archive_dir'"
  fi
  echo "Created directory '$vhost_archive_dir'..."
fi

# lock $vhost_archive_dir not to have other concurring backups
# at the same time
if ! lock_path "$vhost_archive_dir" >/dev/null; then
  error "unable to lock directory $vhost_archive_dir"\
\ "probably there's an ongoing backup running."
fi
trap 'cleanup' HUP INT QUIT ILL TRAP ABRT BUS FPE KILL SEGV \
  PIPE STOP ALRM TERM EXIT

# in case group ownership is different, chgrp vhost_archive_dir to $user_web
group_name=$(stat -c %G "$vhost_archive_dir")
if [ "$group_name" != "$user_web" ]; then
  chgrp "$user_web" "$vhost_archive_dir"
  if [ $? -ne 0 ]; then
    error "unable to chgrp archive dir $vhost_archive_dir to $user_web"
  fi
  echo "Chgrp'd directory '$vhost_archive_dir' to $user_web..."
fi

tmp_archive_dir=`mktemp -d "$vhost_archive_dir/archive_vhost.tmp.XXXXXX"`
if [ $? -ne 0 ]; then
  error "unable to create temporary directory for archiving."
fi

tmp_target_file=$(mktemp "$tmp_archive_dir/$archive_filename.XXXXXX")
if [ $? -ne 0 ]; then
  error "unable to create temporary file"
fi

echo "Archiving web files..."
${debug:+run} "$0-web" $archive_vhost_web_options "$vhost" "$tmp_archive_dir/web"
if [ $? -ne 0 ]; then
  error "unable to archive web files (temp dir $tmp_archive_dir/web)"
fi

if ! `id -u "$user_db" 2>/dev/null >/dev/null`
then
  echo "Skipping db (no such user $user_db)"
else
  echo "Archiving MySQL databases..."
  ${debug:+run} "$0-db" "$vhost" "$tmp_archive_dir/db"
  if [ $? -ne 0 ]; then
    error "unable to archive db files (temp dir $tmp_archive_dir/db)"
  fi
fi

exec >&3

echo "Starting final tar ball archiving..."
base_tmp_target_file=$(basename "$tmp_target_file")
${debug:+run} tar -C "$tmp_archive_dir" --exclude="$base_tmp_target_file" \
  -zScpf "$tmp_target_file" .
if [ $? -ne 0 ]; then
  error "unable to create archive file $tmp_target_file"
fi

# now move the tmp file to the target location
# don't overwrite in case the target file exists
if ! ${debug:+run} mv -n "$tmp_target_file" "$target_file"; then
  error "unable to move '$tmp_target_file' to '$target_file'"
fi

if ! ${debug:+run} chgrp "$user_web" "$target_file"; then
  echo "Warning: unable to chgrp archive file to group $user_web" 1>&2
  sleep 2
fi

if ! ${debug:+run} chmod 0640 "$target_file"; then
  echo "Warning: unable to chmod 640 archive file $target_file" 1>&2
  sleep 2
fi

echo
echo "Successfully saved archive file to '$target_file'"

# successfully ran the backup process, now go through the postrun scripts
# and execute each with: $script  <vhost> <target_file>
(
  self_basename=$(basename "$0")
  postrun_dir="$sys_dir/bin/post-run/$self_basename"
  [ ! -d "$postrun_dir" ] && exit 0

  for file in "$postrun_dir"/*; do
    [ ! -f "$file" -o ! -x "$file" ] && continue
    "$file" "$vhost" "$target_file" &>/dev/null &
  done
) &

exit 0
