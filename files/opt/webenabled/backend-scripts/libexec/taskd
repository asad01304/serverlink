#!/usr/bin/perl -w
use strict;
use warnings;
use File::Basename qw( dirname basename );

BEGIN {
  my $local_perl5_lib = dirname(__FILE__) . '/../lib/perl5/';
  if(-d $local_perl5_lib || -l $local_perl5_lib) {
    unshift(@INC, $local_perl5_lib);
  }
}

# use Errno qw( EINTR );
use Getopt::Std qw( getopts );
use POSIX;# qw( setsid :signal_h :errno_h :sys_wait_h );
use Fcntl qw( :DEFAULT :flock );
use Cloudenabled::Constants (qw( :DEFAULT %CE_TASKS_MSG_TYPES %CE_OP_ST_MAP ));
use Cloudenabled::Util (qw( :DEFAULT ce_tasks_http_request ce_task_cgi_2_ref ));;
use Cloudenabled::Tasks::Util;
use Storable (qw( store_fd fd_retrieve ));

#use DB_File;
#use Time::HiRes qw();
#use Digest::SHA qw( hmac_sha256_hex );
#use CGI::Util qw( escape );
#use Socket qw( AF_UNIX SOCK_STREAM PF_UNSPEC );
#use IO::Handle;

use constant CE_TASKD_VERSION => '1.2.1.0';

use constant CE_TASKD_WARN    => 1;
use constant CE_TASKD_ERR     => 2;
use constant CE_TASKD_DEBUG   => 4;
use constant CE_TASKD_STD     => 8;

use constant CE_TASKD_MAX_OUTPUT_SIZE => 1024 * 1024;

our $default_config = dirname(__FILE__) . "/../../compat/taskd/config/taskd.conf";
our $log_file       = '/dev/null';
our $debug          = 0;
our $saved_errno;

our $program  = basename($0);

our %v = ();
our %values_storage = ();

our $n_childs   = 0;
our $max_childs = 6;

our @report_failed      = ();
our @set_running_failed = ();

our @waiting_report = ();

our $lock_file;

our $conf = {};
#our($target_url, $uid, $key, $output_dir, $cache_file, $dbh, %cache);
our($http_child_pid);
our $child_status  = {};
our $report_status = {};
our $exec_status   = {};

our %config_defaults = (
  scripts_path   => '/opt/cloudenabled/scripts',
  max_exec_child => 5,
);

sub usage {
  print "Usage: $0 [ options ]

  Options:
    -d                      Print debug messages
    -c config_file.conf     Use an alternate config file
    -h                      Help. Displays this message.
    -F                      Foreground, don't daemonize
";
  exit(1);
}

sub initializeDefaults {
  my($conf, $config_defaults) = @_;

  if(!defined($conf) || !ref($conf) || ref($conf) ne 'HASH') {
    warn 'initializeDefaults(): error - empty conf parameter';
    return 0;
  } elsif(!defined($config_defaults) || !ref($config_defaults) || ref($config_defaults) ne 'HASH') {
    warn 'initializeDefaults(): error - empty config_defaults parameter';
    return 0;
  }

  foreach my $k (keys %$config_defaults) {
    if(!exists($conf->{$k})) {
      $conf->{$k} = $config_defaults->{$k};
    }
  }

  if(! -e $conf->{work_dir}) {
    mkdir($conf->{work_dir});
  }

  if(-d $conf->{work_dir} && ! -e $conf->{work_dir} . '/task_output') {
    mkdir($conf->{work_dir} . '/task_output');
  }

  if(!exists($conf->{max_output_size})) {
    $conf->{max_output_size} = CE_TASKD_MAX_OUTPUT_SIZE;
  }

  return 1;
}

sub _has_missing_config_directives {
  my $conf = shift || return 0;

  my @required_directives = (qw(
    scripts_path api_url uuid key work_dir unpriv_user
  ));

  foreach my $p (@required_directives) {
    if(!exists($conf->{$p}) || length($conf->{$p}) == 0) {
      warn "Error: Parameter '$p' not set in config file.\n";
      return 1;
    }
  }

  return 0;
}

sub validate_config {
  my $conf = shift;

  if($conf->{max_exec_child} !~ /^\d+$/) {
    warn "Invalid value for parameter: max_exec_child. Should be numeric\n";
    return 0;
  }

  if(!-e $conf->{work_dir}) {
    warn "Error: work directory '$conf->{work_dir}' doesn't exist.\n";
    return 0;
  } elsif(! -d $conf->{work_dir}) {
    warn "Error: path '$conf->{work_dir}' is not a directory.\n";
    return 0;
  }

  if(!chdir($conf->{work_dir})) {
    warn "Error: unable to enter into work directory '$conf->{work_dir}'\n";
    return 0;
  }

  return 1;
}

sub _encode_file_base64 {
  my $file = shift;
  my $buf;
  my $n = 0;
  my $nr;
  my $b64_str = '';

  if(!open(F, $file)) {
    return undef;
  }

  while($nr = read(F, $buf, 70*57) && $n <= CE_TASK_MAX_OUTPUT_LEN) {
    $n += $nr;
    $b64_str .= encode_base64($buf);
  }
  close(F);

  # warn sprintf("b64 = %s\n", $b64_str);
  return $b64_str;
}

sub _set_autoflush_noblock {
  my $fd = shift;

  my $prev_fd = select();
  select($fd);
  fcntl($fd, F_SETFL, O_NONBLOCK);
  $| = 1;

  select($prev_fd);
}

sub _drop_privs {
  my($uid, $gid) = @_;

  $( = $) = $gid;  # setgid(); equivalent
  if($!) {
    warn "Error: Unable to setgid() to target_group: $!";
    return 0;
  }

  $< = $> = $uid;  # setuid(); equivalent
  if($!) {
    warn "Error: Unable to setuid() to target_user: $! \n";
    return 0;
  }

  return 1;
}

sub full_drop_privs {
  my($username, $group) = @_;

  my(@user_fields, $uid, $gid);
  if(!(@user_fields = getpwnam($username))) {
    taskd_log(CE_TASKD_ERR, "user '$username' doesn't exist.");
    return 0;
  }
  $uid = $user_fields[2];

  if($group eq '|' && !(my $gr = getgrgid($user_fields[3]))) {
    taskd_log(CE_TASKD_ERR, "gid ' $user_fields[3]' doesn't exist in the system, even though assigned to user '$username'");
    return 0;
  } elsif($group eq '|') {
    $gid = $user_fields[3];
    $group = $gr;
  } elsif(!($gid = getgrnam($group))) {
    taskd_log(CE_TASKD_ERR, "group '$group' doesn't exist.");
    return 0;
  }

  if(!_drop_privs($uid, $gid)) {
    taskd_log(CE_TASKD_ERR, "unable to drop privileges to user '$uid' and group '$gid'");
    return 0;
  }

  # set the variables appropriately
  undef(%ENV);
  $ENV{'USER'} = $ENV{'LOGNAME'} = $username;
  $ENV{'HOME'} = $user_fields[7];

  $debug and debug_log(sprintf("Dropped privs to user '%s' (uid: %d) and group '%s' (gid: %d)", 
         $username, $uid, $group, $gid));

  return 1;
}

sub sig_term_main {
  my $sig_name = shift;

  my %sig_map = (
    INT     =>  2,
    TERM    => 15,
    default => 15,
  );

  taskd_log(undef, "received SIG${sig_name} - shutting down");

  if(exists($v{http_pid})) {
    my $sig_n = exists($sig_map{$sig_name}) ? $sig_map{$sig_name} : $sig_map{default};
    kill($sig_n, $v{http_pid});
  }

  exit(0);
}

sub sig_hup_main {
  my $tmp;
  
  if($tmp = cloudenabled_parse_conf($default_config)) {
    %v = %$tmp;
    $debug and ce_log("Reloaded with data = " . Dumper(\%v));
    ce_log("Received HUP. Successfully reloaded config.");
  } else {
    ce_log("Received HUP. But config file has problems, config not reloaded.");
  }
}

sub master_sig_chld {
  while((my $pid = waitpid(-1, WNOHANG)) > 0) {
    my $ret = $? >> 8;

    if($pid eq $v{http_pid}) {
      delete($v{http_pid});
    }

    my $task_id;
    if(!($task_id = $v{"pid:$pid:task"})) {
      taskd_log(CE_TASKD_ERR, "SIG_CHLD - No known task for pid $pid");
      return 0;
    }

    # it's an exec child

    $v{n_exec_child}--;

    my $task_ref    = $v{"task:$task_id"};
   
    taskd_log(CE_TASKD_STD,
      sprintf('Finished execution of task %d (pid %d, activity %d, attempt %d), exit code: %d',
                                $task_id, $pid, $task_ref->{activity_id},
                                $task_ref->{attempt_id}, $ret));

    my $report_r = {
        __op => 'report',
           T => $task_id,
           e => time(),
           r => $ret,
    };

    eval { store_fd($report_r, \*TO_CHILD); };

    delete($v{"pid:$pid:task"});
    delete($v{"activity:" . $task_ref->{activity_id} . ":pid"});
    delete($v{"task:$task_id"});
    undef($task_ref);
  }

  $SIG{CHLD} = \&master_sig_chld;
};

sub report_task {
  my($msg) = @_;

  my $task_id  = $msg->{T};
  my $ret      = $msg->{r};
  my $end_time = $msg->{e};

  my $out_file = $conf->{work_dir} . '/task_output/' . $task_id;

  if(!open(OUTPUT_F, $out_file)) {
    taskd_log(CE_TASKD_ERR,
      "unable to open output file '$out_file' for task $task_id: $!");
    return 0;
  }

  my($read_len, $n);
  $read_len = $n = 0;
  my $output_str = '';
  while($read_len <= $conf->{max_output_size} &&
    defined($n = sysread(OUTPUT_F, my $buf, 8192)) && $n > 0) {
    $debug and debug_log("read $n characters from file '$out_file'");
    $output_str .= $buf;
    $read_len += $n;
  }
  close(OUTPUT_F);

  my $output_base64 = eval { encode_base64($output_str); };
  if($@) {
    taskd_log(CE_TASKD_ERR,
    "unable to encode to base64 the output of file '$out_file' (task $task_id)");
    return 0;
  }

  my $ht_ret = ce_tasks_http_request({
      __api_url => $conf->{api_url},
          __key => $conf->{key},
       __method => 'post',
             op => CE_TASK_OP_REPORT,
             _S => $v{session_id},
              T => $task_id,
              o => $output_base64,
              r => $ret,
              e => $end_time,
            });

  undef($output_base64);
  undef($output_str);

  if(ce_task_was_successful($ht_ret)) {
    $debug and debug_log("successfully reported execution of task $task_id");
    unlink($out_file) or taskd_log(CE_TASKD_WARN,
      "unable to remove output file for task $task_id: $!");
    return 1;
  } else {
    taskd_log(CE_TASKD_ERR, "failed to report the execution of task ". 
      "$task_id. server returned: " .  ce_map_op_st_str($ht_ret->{_s}) .
      (exists($ht_ret->{_e}) ? '. Error msg: ' . $ht_ret->{_e} : ''));
    return 0;
  }
}

sub exec_child {
  my($def) = @_;

  $debug and debug_log("attempting to parse task definition:", $def);

  my($task_id, $flags, $attempt_id, $activity_id) = split(/,/, $def->{props});

  if(exists($v{"activity:$activity_id:pid"})) {
    my $msg = "skipping task %d. There's another pid (%d) running for the activity %d";
    taskd_log(CE_TASKD_WARN, sprintf($msg, $task_id, $v{"activity:$activity_id:pid"}, $activity_id));
    return 0; # there's already another task running for this activity
  }

  if(exists($v{"task:$task_id:pid"})) {
    taskd_log(CE_TASKD_WARN, "there's another process executing this task (!?!?). Skipping");
    return 0;
  }

  if($flags & CE_TASK_FL_DROP_PRIVS && !exists($def->{exec_user})) {
    taskd_log(CE_TASKD_ERR, "missing parameter exec_user in task $task_id");
    return 0;
  }

  if($flags & CE_TASK_FL_READ_STDIN && !exists($def->{stdin_data})) {
    taskd_log(CE_TASKD_ERR, "missing stdin_data in task $task_id");
    return 0;
  } elsif($flags & CE_TASK_FL_READ_STDIN) {
    $debug and debug_log("task $task_id expects data from stdin");
    pipe(EXEC_READ_FD, EXEC_WRITE_FD);
    ce_set_autoflush_noblock(\*EXEC_READ_FD);
    ce_set_autoflush_noblock(\*EXEC_WRITE_FD);
  }

  my $pid = fork();

  if(!defined($pid)) {
    taskd_log(CE_TASKD_ERR, "unable to fork exec child. $!");
    return 0;
  } elsif($pid) {
    my $task_ref = {
      activity_id => $activity_id,
      pid         => $pid,
      attempt_id  => $attempt_id,
    };

    $v{"task:$task_id"}             = $task_ref;
    $v{"pid:$pid:task"}             = $task_id;
    $v{"activity:$activity_id:pid"} = $pid;

    $v{n_exec_child}++;

    if($flags & CE_TASK_FL_READ_STDIN) {
      close(EXEC_READ_FD);
      $debug and debug_log("printing data to exec client: " .
                              $def->{stdin_data});
      print EXEC_WRITE_FD $def->{stdin_data};
      close(EXEC_WRITE_FD);
    }

    $debug and 
      debug_log("forked child to run task $task_id, pid $pid", $task_ref);

    push(@{ $v{set_running} }, $task_id);

    return 1;
  }

  # now the exec child

  sleep(0.5); # wait a bit for the parent to set itself (above)

  $0 = $program . "-exec-child: running task $task_id";
  my $errmsg;

  if($flags & CE_TASK_FL_READ_STDIN) {
    close(EXEC_WRITE_FD);
    if(!open(STDIN, '<&=', fileno(EXEC_READ_FD))) {
      $errmsg = "Error: unable to redirect stdin. $!";
      goto ERR_BEFORE_EXEC;
    }
  }

  my $outfile = sprintf('%s/task_output/%d', $conf->{work_dir}, $task_id);
  if(!open(STDOUT, ">$outfile")) {
    $errmsg = "Error: unable to open output file. $!";
    goto ERR_BEFORE_EXEC;
  }

  # task requests to drop privileges
  if($flags & CE_TASK_FL_DROP_PRIVS) {
    my $user  = $def->{exec_user};
    my $group = exists($def->{exec_group}) ? $def->{exec_group} : '|';
    if(!full_drop_privs($user, $group)) {
      goto ERR_BEFORE_EXEC;
    }
  }

  taskd_log(CE_TASKD_STD,
    "Preparing to run task $task_id, attempt $attempt_id, activity " .
      $activity_id);

  open(STDERR, '>&STDOUT');

  # set the environment variables defined in the command (if any)
  my $i=1;
  while(exists($def->{"e${i}n"})) {
    $ENV{$def->{"e${i}n"}} = $def->{"e${i}v"};
    $i++;
  }

  my @cmd = ($conf->{scripts_path} . '/' . shift(@{ $def->{cmd} }));
  push(@cmd, @{ $def->{cmd} });

  $debug and 
    debug_log("Executing task $task_id, activity $activity_id, command: " .
      join(' ', @cmd));

  if(!exec(@cmd)) {
    $errmsg = "Failed to execute task $task_id, attempt $attempt_id, " .
              "activity $activity_id: $!\n";
  }

ERR_BEFORE_EXEC:
  $errmsg and taskd_log(CE_TASKD_ERR, $errmsg);
  $errmsg and print $errmsg; # save in the command output
  exit(127);
}

sub taskd_log {
  my($flag, $msg) = @_;

  if(!defined($flag)) {
    $flag = CE_TASKD_STD;
  }

  my $prep = $program;
  if($flag & CE_TASKD_ERR) {
    $prep .= ' - error: ';
  } elsif($flag & CE_TASKD_WARN) {
    $prep .= ' - warning: ';
  } elsif($flag & CE_TASKD_DEBUG) {
    $prep .= ' - debug: ';
  } elsif($flag & CE_TASKD_STD) {
    $prep .= ': ';
  }

  if(substr($msg, length($msg) - 1) ne "\n") {
    $msg .= "\n";
  }

  ce_log(\*TASKD_LOG, $prep . $msg);
}

sub debug_log {
  my($msg, $ref) = @_;

  if(defined($ref)) {
    $msg .= ' ' . Dumper($ref);
  }

  taskd_log(CE_TASKD_DEBUG, $msg);
}

sub log_msg_err {
  my($msg_str, $ret) = @_;

  my $st = exists($ret->{status}) ? $ret->{status} :
           exists($ret->{_s})     ? $ret->{_s}     : '';

  my $err = exists($ret->{errmsg}) ? $ret->{errmsg} :
            exists($ret->{_e})     ? $ret->{_e}     : '';

  taskd_log(CE_TASKD_ERR, $msg_str . ' '.  ce_map_op_st_str($st) .  '. ' . $err);
}

sub start_session {
  my $params = {
    __api_url => $conf->{api_url},
    __method  => 'post',
    __key     => $conf->{key},
     U => $conf->{uuid},
    op => CE_TASK_OP_HELLO,
    v  => CE_TASKD_VERSION,
    t  => time(),
  };

  return ce_tasks_http_request($params);
}

sub retrieve_msgs {
  my $params = {
    __api_url => $conf->{api_url},
    __method  => 'get',
    __key     => $conf->{key},
    _S        => $v{session_id},
    op        => CE_TASK_OP_GET_MSGS,
    N         => $v{can_run},
  };

  return ce_tasks_http_request($params);
}

sub set_running {
  my($tasks) = @_;

  my $task_str;
  if(ref($tasks)) {
    $task_str = join(', ', @{ $tasks });
  } else {
    $task_str = $tasks;
  }

  my $params = {
    __api_url => $conf->{api_url},
    __method  => 'post',
    __key     => $conf->{key},
    _S        => $v{session_id},
     T        => $tasks,
    op        => CE_TASK_OP_SET_RUNNING,
  };

  my $ht_ret = ce_tasks_http_request($params);

  if(!ce_task_was_successful($ht_ret)) {
    taskd_log(CE_TASKD_WARN, "failed to notify about running tasks: " .
                                                                $task_str);
    taskd_log(CE_TASKD_WARN, "server returned: " .
                  ce_map_op_st_str($ht_ret->{_s}) .
                  (exists($ht_ret->{_e}) ? '. Error msg: ' . $ht_ret->{_e} : ''));

    return 0;
  } elsif($debug) {
    debug_log("successfully notified about running tasks: $task_str");
  }

  return 1;
}

sub ran_internal {
  my($msg_id) = @_;

  my $params = {
    __api_url => $conf->{api_url},
    __method  => 'post',
    __key     => $conf->{key},
    _S        => $v{session_id},
     I        => $msg_id,
    op        => CE_TASK_OP_RAN_INTERNAL,
  };

  my $ht_ret = ce_tasks_http_request($params);

  if(!ce_task_was_successful($ht_ret)) {
    taskd_log(CE_TASKD_WARN, "failed to notify about internal task run: " .
                              "msg_id: $msg_id");

    taskd_log(CE_TASKD_WARN, "server returned: " .
                  ce_map_op_st_str($ht_ret->{_s}) .
                  (exists($ht_ret->{_e}) ? '. Error msg: ' . $ht_ret->{_e} : ''));

    return 0;
  } elsif($debug) {
    debug_log("successfully notified about internal task run, msg_id: $msg_id");
  }

  return 1;
}

sub http_child {
  pipe(FROM_CHILD,  TO_PARENT);
  pipe(FROM_PARENT, TO_CHILD);

  _set_autoflush_noblock(\*FROM_CHILD);
  _set_autoflush_noblock(\*FROM_PARENT);
  _set_autoflush_noblock(\*TO_PARENT);
  _set_autoflush_noblock(\*TO_CHILD);
  select(\*STDOUT);

  my $pid = fork();
  if(!defined($pid)) {
    taskd_log(CE_TASKD_ERR, "unable to fork http_child: $!");
    return 0;
  } elsif($pid) {
    close(FROM_PARENT);
    close(TO_PARENT);
    $debug and debug_log("forked http child, pid = $pid");
    $v{http_pid} = $pid;
    return 1;
  }

  local $SIG{CHLD} = 'IGNORE';

  close(FROM_CHILD);
  close(TO_CHILD);

  $program .= "-http";
  $0 = $program;

  setsid();
  full_drop_privs($conf->{unpriv_user}, '|');

  $v{can_run} = $conf->{max_exec_child} - $v{n_exec_child};
  taskd_log(undef, "starting");

  use MIME::Base64 qw( encode_base64 );

  while(1) {
    my $fetch_immediately = 0;

    if(!exists($v{session_id})) {
      my $sess = start_session();
      $debug and debug_log("sess = ", $sess);
      ce_convert_task_ret($sess);
      if(ce_was_successful($sess)) {
        taskd_log(CE_TASKD_STD, "started session " . $sess->{_S});
        $v{session_id}        = $sess->{_S};
        $v{session_last_used} = time();
        $v{session_poll_intvl}        = $v{poll_interval}     = $sess->{P};
        $v{session_error_retry_intvl} = $v{error_retry_intvl} = $sess->{E};
      } else {
        log_msg_err("Unable to create session. Server returned:", $sess);
        $debug and debug_log("sleeping for $v{error_retry_intvl} seconds");
        sleep($v{error_retry_intvl});
        next;
      }
    }

    my $msg = retrieve_msgs();
    $debug and debug_log("Received msg = ", $msg);
    exists($msg->{_w}) and taskd_log(CE_TASKD_WARN, "server warned: ". $msg->{_w});

    if(!ce_task_was_successful($msg)) {
      log_msg_err("Unable to retrieve messages. Server returned:", $msg);
      $debug and debug_log("Sleeping for $v{error_retry_intvl} seconds");
      sleep($v{error_retry_intvl});
      next;
    }

    my $status = $msg->{_s};

    if($status == CE_OP_ST_HELLO_REQUIRED) {
      delete($v{session_id}) if(exists($v{session_id}));
      delete($v{session_last_used}) if(exists($v{session_last_used}));

      taskd_log(CE_TASKD_WARN, "server is requiring re-authentication. " .
        "Waiting $v{error_retry_intvl} seconds before re-trying");

      $debug and taskd_log(CE_TASKD_WARN, "Sleeping for $v{error_retry_intvl} seconds");
      sleep($v{error_retry_intvl});
      next; # go back and try to authenticate
    } elsif($status != CE_OP_ST_SUCCESS) {
      taskd_log(CE_TASKD_ERR, "request returned status: " . ce_map_op_st_str($status));
      goto REPORT_AND_WAIT;
    }

    if(!exists($msg->{_M})) {
      taskd_log(CE_TASKD_ERR, "message type missing in request. Probably a server problem");
      goto REPORT_AND_WAIT;
    } elsif(!exists($CE_TASKS_MSG_TYPES{$msg->{_M}})) {
      taskd_log(CE_TASKD_ERR, "unknown message type '$msg->{_M}'. taskd is probably outdated");
      goto REPORT_AND_WAIT;
    }

    my $msg_type = $msg->{_M};
    if($msg_type == CE_TASK_MSG_RUN_TASKS) {
      $msg->{n} == 0 and goto REPORT_AND_WAIT;
      $msg->{__op} = 'run_tasks';
      store_fd($msg, \*TO_PARENT);
    } elsif($msg_type == CE_TASK_MSG_CHANGE_POLL) {
      $v{poll_interval}        = $msg->{P};
      $v{error_retry_intvl} = $msg->{E};
      taskd_log(undef, "changing poll interval to $v{poll_interval} seconds");
      if(exists($msg->{e})) {
        $v{poll_expires} = time() + $msg->{e};
      }
      ran_internal($msg->{_I});
    } elsif($msg_type == CE_TASK_MSG_NO_MESSAGES && $debug) {
      debug_log("No messages available. Doing nothing.");
    }
      
  REPORT_AND_WAIT:
    if($#set_running_failed >= 0) {
      if(set_running(\@set_running_failed)) {
        taskd_log(undef, "successfully re-reported previously running " .
          "tasks: " . join(', ', @set_running_failed));
        @set_running_failed = ();
      } else {
        taskd_log(CE_TASKD_ERR,
          "failed to retry notifying the controller about running tasks");
      }
    }

    if($#report_failed >= 0) {
      for(my $i=0; $i <= $#report_failed; $i++) {
        my $task_r = $report_failed[$i];
        taskd_log(undef, "retrying to report task " . $task_r->{T});
        if(report_task($task_r)) {
          taskd_log(undef, "successfully retried the report of task " .
            $task_r->{T});
          splice(@report_failed, $i, 1);
          $fetch_immediately = 1;
        } else {
          taskd_log(CE_TASKD_ERR,
            "failed retrying reporting task " . $task_r->{T});
        }
      }
    }

    if(exists($v{poll_expires}) && $v{poll_expires} <= time() ) {
      $v{poll_interval}     = $v{session_poll_intvl};
      $v{error_retry_intvl} = $v{session_error_retry_intvl};
      taskd_log(undef, "returning poll interval to $v{session_poll_intvl} seconds");
      delete($v{poll_expires});
    }

    if(!$fetch_immediately) {
      $v{fdv} = '';
      vec($v{fdv}, fileno(FROM_PARENT), 1) = 1;
      my $fetch_time = time() + $v{poll_interval}; 
      while(time() < $fetch_time) {
        my $timeout = $fetch_time - time();
        $debug and debug_log("sleeping for $timeout seconds");
        $0 = $program . " sleeping for $timeout seconds";

        my $n = select($v{fdv}, undef, undef, $timeout);
        if($n > 0) {
          while(my $msg = eval { fd_retrieve(\*FROM_PARENT) }) {
            child_parse_n_execute($msg);
          }
          # processed all, go see if the server has more msgs
          last;
        }
      }
    }
  }
}

sub master_parse_n_execute {
  my $msg = shift;

  if(!exists($msg->{__op})) {
    taskd_log(CE_TASKD_ERR, "missing op instruction in msg received");
    return 0;
  }

  my $op = $msg->{__op};

  if($op eq 'run_tasks') {
    my $can_run = $conf->{max_exec_child} - $v{n_exec_child};
    if($can_run <= 0) {
      taskd_log(CE_TASKD_WARN, "received tasks to run, but already ".
                             "executing the maximum number of tasks allowed");
      return 0;
    }

    for(my $n=1; $n <= $msg->{n}; $n++) {
      if(!exists($msg->{"t${n}"})) {
        taskd_log(CE_TASKD_ERR, "missing task definition for index $n");
        next;
      } elsif(!exists($msg->{"c${n}"})) {
        taskd_log(CE_TASKD_ERR, "missing command definition for index $n");
        next;
      }

      my $def = {
        props => $msg->{"t${n}"},
        cmd   => $msg->{"c${n}"},
      };

      if(exists($msg->{"s${n}"})) {
        $def->{stdin_data} = $msg->{"s${n}"};
      }
      if(exists($msg->{"u${n}"})) {
        $def->{exec_user} = $msg->{"u${n}"};
      }
      if(exists($msg->{"g${n}"})) {
        $def->{exec_group} = $msg->{"g${n}"};
      }

      my $i=1;
      while(exists($msg->{"e${n}n${i}"}) && exists($msg->{"e${n}v${i}"})) {
        $def->{"e${i}n"} = $msg->{"e${n}n${i}"};
        $def->{"e${i}v"} = $msg->{"e${n}v${i}"};
        $i++;
      }

      exec_child($def);
      undef($def);
    }

    if($#{ $v{set_running} } >= 0) {
      my $notify_r = { __op       => 'set_running',
                       task_id    => $v{set_running},
                       can_run    => $conf->{max_exec_child} - $v{n_exec_child}, 
                     };

      $debug and debug_log("notifying http client about running tasks " .
                  join(', ', @{ $v{set_running} }) . ' ' . Dumper($notify_r));

      eval { store_fd($notify_r, \*TO_CHILD) };
      delete($v{set_running});
      undef($notify_r);
    }

  } else {
    taskd_log(CE_TASKD_ERR, "unknown operation requested");
    return 0;
  }

}

sub child_parse_n_execute {
  my $msg = shift;

  if(!defined($msg)) {
    return 0;
  }

  $debug and debug_log("received message: ", $msg);
  if(!exists($msg->{__op})) {
    taskd_log(CE_TASKD_ERR, "missing op instruction in msg received");
    return 0;
  }

  my $op = $msg->{__op};

  if($op eq 'set_running') {
    if(set_running($msg->{task_id})) {
      $v{can_run} = $msg->{can_run};
    } elsif(ref($msg->{task_id}) eq 'ARRAY') {
      push(@set_running_failed, @{ $msg->{task_id} });
    } else {
      push(@set_running_failed, $msg->{task_id});
    }
  } elsif($op eq 'report') {
    if(!report_task($msg)) {
      push(@report_failed, $msg);
    }
  } else {
    taskd_log(CE_TASKD_ERR, "unknown operation requested");
    return 0;
  }

  return 1;
}


# main()

my $getopt_flags = 'dhFc:';
my %opts;

if(!getopts($getopt_flags, \%opts)) {
  warn "For more command line options, please use the -h option.\n";
  exit(1);
}

if(exists($opts{'h'})) {
  usage();
}

if(exists($opts{'c'})) {
  $default_config = $opts{'c'};
}

if(exists($opts{'d'})) {
  eval { use Data::Dumper; };
  if($@) {
    warn("Error: unable to enter in debug mode: $@\n");
    exit(1);
  }
  $debug = 1;
}

if(!($conf = cloudenabled_parse_conf($default_config))) {
  exit(1);
}

if(_has_missing_config_directives($conf)) {
  exit(1);
}

initializeDefaults($conf, \%config_defaults);

if(!validate_config($conf)) {
  warn "Error: malformed configuration configuration file. Exiting.\n";
  exit(1);
}

$lock_file = $conf->{work_dir} . '/' . "$program.lock";

if(!open(LOCK_FILE, '>', $lock_file)) {
  warn "Error: unable to open lock file for writing. $!\n";
  exit(1);
}

if(!flock(LOCK_FILE, LOCK_EX | LOCK_NB)) {
  warn "Error: there's already another instance running. Exiting.\n";
  close(LOCK_FILE);
  exit(1);
}

my $pid_file = $conf->{work_dir} . '/' . "$program.pid";
if(!open(PID_FILE, '>', $pid_file)) {
  warn "Error: couldn't open pid file '$pid_file': $!\n";
  flock(LOCK_FILE, LOCK_UN);
  close(LOCK_FILE);
  exit(1);
}

if(print PID_FILE $$, "\n") {
  close(PID_FILE);
} else {
  warn "Error: unable to write pid to pid_file '$pid_file': $!\n";
}

if(exists($opts{F})) { # run in foreground
  open(STDERR, '>&STDOUT') or die "Error: can't dup stderr to stdout. $!\n";
  open(TASKD_LOG, '>&STDOUT') or die "Error: can't dup stderr to log file. $!\n";
} else {
  cloudenabled_daemonize($log_file);
}

local $SIG{CHLD} = \&master_sig_chld;
local $SIG{HUP}  = \&sig_hup_main;
local $SIG{TERM} = $SIG{INT} = \&sig_term_main;

$v{n_exec_child}      =  0;
$v{error_retry_intvl} = 30;

$0 = $program . '-master';
taskd_log(CE_TASKD_STD, "started");

while(1) {
  if(http_child()) {
    $v{fdv} = '';
    vec($v{fdv}, fileno(FROM_CHILD), 1) = 1;
  }

  while(exists($v{http_pid})) {
    my $n = select($v{fdv}, undef, undef, undef);
    if($n > 0) {
      while(my $msg = eval { fd_retrieve(\*FROM_CHILD) }) {
        $debug and debug_log("received: " . Dumper($msg));
        master_parse_n_execute($msg);
      }
    }
  }

  sleep(60);
}

close(TASKD_LOG);
