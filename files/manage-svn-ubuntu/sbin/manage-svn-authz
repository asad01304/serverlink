#!/usr/bin/perl -w

use strict;
use File::Temp qw(tempfile);

my %aliases = ();
my %groups = ();
my %paths = ();

sub usage(@)
{
	my $context = shift;
	unless (!defined($context)) {
		if ($context eq 'alias') {
			print "Usage: $0 FILE alias [ALIAS [definition]]\n";
		} elsif ($context eq 'group') {
			print "Usage: $0 FILE group [GROUP [[+/-]ACCOUNT ...]]\n";
		} elsif ($context eq 'perms') {
			print "Usage: $0 FILE perms [PATH [ENTITY [r/rw/none/- [R/recursive]]]]\n";
		} elsif ($context eq 'user') {
			print "Usage: $0 FILE user [NAME]\n";
		} else {
			print "$0: unrecognized help topic '$context'\n";
		}
	} else {
		print "Usage: $0 FILE <print/alias/group/perms/user> ARG1 [ARG2 .. ARGn]\n";
	}
	exit 1
}

usage() if ($#ARGV < 1);

my $authz_file = shift;

usage($ARGV[0]) if $authz_file eq 'help';

if (! -f "$authz_file")
{
	print "$0: cannot find specified file '$authz_file', it must exists!\n";
	exit 1
}

my $action = shift;
usage() unless $action =~ /^(alias|group|perms|print|user)$/;

my @args = @ARGV;

sub read_authz($)
{
	my $file = shift;
	return 0 unless (defined($file) and -f "$file");
	open AUTHZ_FILE, "<$file" or die $!;

	my $section = undef;
	my $repo = undef;
	my $path = undef;
	while (<AUTHZ_FILE>)
	{
		chomp;
		s/^\s*#.*$//;
		s/^\s+//;
		s/\s+$//;
		next if /^$/;

		if (/^\s*\[(aliases|groups)\]\s*$/) {
			$section = $1;
			next;
		}
		if (/^\s*\[([\w-]+:)?(\/.*)?\]\s*$/) {
			$section = 'paths';
			$repo = defined($1) ? $1 : '';
			$path = defined($2) ? $2 : '';
			next;
		}

		# real stuff
		if (defined($section) && /^\s*(([@&\$])?[\w-]+|\*)\s*=\s*(.*)$/) {
			if (!defined($1)) {
#				print "$0: invalid line encountered '$_'\n";
				next;
			}
			my $key = $1;
			my $modifier = defined($2) ? $2 : undef; # XXX: unused?
			my $value = defined($3) ? $3 : '';

			if ($section eq 'aliases') {
				$aliases{$key} = $value if $value;
			} elsif ($section eq 'groups') {
				push @{$groups{$key}}, split(/\s*,\s*/, $value);
			} elsif ($section eq 'paths') {
				my $object = $repo . $path;
				$value = 'none' unless $value;
				# XXX: the below is "grey" - I believe that SVN use the first
				#      object definition and skips all subsequent ones, so
				#      I'm ignoring subsequent definitions too.
				$paths{$object}{$key} = $value unless exists $paths{$object}{$key};
#			} else {
#				print "$0: unknown section name '$section'\n";
			}
			next;
		}
#		print "Bogus line: '$_'\n";
	};

	close AUTHZ_FILE;
	return 1;
}

# a helper subroutine for sorting permission records
sub perms
{
	my $result = 0;
	my %rank = ();
	$rank{'-'} = 10; # regular users
	$rank{'&'} = 20; # aliases
	$rank{'@'} = 30; # groups
	$rank{'$'} = 40; # for $authenticated
	$rank{'*'} = 50; # for anonymous users

	sub parse_key($)
	{
		my $key = shift;
		my $prefix;
		return $prefix if (($prefix) = ($key =~ /^([@&\*\$])/));
		return '-';
	}

	$result = $a cmp $b
		if (($result = $rank{parse_key($a)} cmp $rank{parse_key($b)}) == 0);

	return $result;
}

# get list of all defined objects sorted alphabetically
sub get_objects
{
	my @result = ();
	if (keys (%paths)) {
		foreach (sort keys %paths) {
			push @result, $_;
		}
	}
	return @result;
}

sub get_groups
{
	my @result = ();
	my $member = shift;
	if (keys (%groups)) {
		foreach my $key (keys %groups) {
			if ($member) {
				foreach (@{$groups{$key}}) {
					if ($_ eq $member) {
						push @result, $key;
						last;
					}
				}
			} else {
				push @result, $key;
			}
		}
	}
	return @result;
}

# a helper function to get actual permissions for a specified entity
# expects ($object, $entity)
# returns a string with permissions (prefixed with # if they were inherited)
sub get_permissions($$)
{
	my $result = '';
	my $object = shift;
	my $entity = shift;
	my @tmp_groups = get_groups($entity);
	my (undef, $req_repo, $req_path) = ($object =~ /^(([\w-]+):)?(\/.*)/);

	$req_repo = '' if !defined($req_repo);
	$req_path = '' if !defined($req_path);
	return '' unless ($req_path && $req_path =~ /^\//);

	# try explicit definition first
	if (exists $paths{$object}{$entity}) {
		return ($paths{$object}{$entity} ne 'none' ? $paths{$object}{$entity} : '');
	}

	my @checklist = ();
	push @checklist, $entity; # we need to check it first
	foreach (@tmp_groups) { # prefix groups with '@' and push into the list
		push @checklist, '@' . $_;
	}
	push @checklist, '$authenticated'; # this is a check for authenticated users
	push @checklist, '*'; # this is a check for anonymous users

	foreach my $tmp_object (get_objects()) {
		my (undef, $tmp_repo, $tmp_path) = ($tmp_object =~ /^(([\w-]+):)?(\/.*)/);
		$tmp_repo = '' if !defined($tmp_repo);
		$tmp_path = '' if !defined($tmp_path);
		next unless ($tmp_path && $tmp_path =~ /^\//);

		next if ($tmp_repo && $req_repo ne $tmp_repo);

		next unless (index(($req_path eq '/' ? '' : $req_path) . '/', ($tmp_path eq '/' ? '' : $tmp_path) . '/') == 0);

		foreach my $tmp_entity (@checklist) {
			$result = $paths{$tmp_object}{$tmp_entity} if exists $paths{$tmp_object}{$tmp_entity};
			last if defined($result) && $result;
		}
		next if defined($result) && $result;
	}

	return '#' . ($result ne 'none' ? $result : '');
}

sub write_authz
{
	my $authz_file = shift;
	my $tmp_file = undef;
	my $saved_channel = undef;
	if (defined($authz_file) && $authz_file) {
		$tmp_file = File::Temp->new( TEMPLATE => "$authz_file.XXXXXX", UNLINK => 0, SUFFIX => '.tmp' );
		$saved_channel = select;
		unless (select $tmp_file)
		{
			return 0;
		}
	}

	print "# WARNING: This file has been generated by $0, any manual changes might be lost!\n";

	if (keys (%aliases)) {
		print "[aliases]\n";
		foreach my $key (keys %aliases) {
			print "$key = $aliases{$key}\n" if $aliases{$key};
		}
		print "\n";
	}

	if (keys (%groups)) {
		print "[groups]\n";
		foreach my $key (keys %groups) {
			my $string = '';
			foreach my $rec (@{$groups{$key}}) {
				$string .= $rec . ', ';
			}
			chop $string; # chopping space
			chop $string; # chopping comma
			print "$key = $string\n" if $string;
		}
		print "\n";
	}

	foreach my $object ( sort keys %paths) {
		next unless keys %{$paths{$object}};
		print "[$object]\n";
		foreach my $key ( sort perms keys %{$paths{$object}} ) {
			print "$key = " . (($paths{$object}{$key} ne 'none') ? $paths{$object}{$key} : '') . "\n";
		}
		print "\n";
	}

	if (defined($authz_file) && $authz_file) {
		return 0 unless (select $saved_channel && $tmp_file->close() && rename($tmp_file, $authz_file));
	}
	return 1;
}

# returns 0 - an error occured
#         1 - success (no additional actions are required)
#         2 - success (need to update config)
#	 10 - requested entity wasn't found
#	 11 - requested entity is invalid
sub process_command($)
{
	my $dirty = 0;
	my $command = shift;
	if ($command eq 'alias') {
		unless ($args[0]) { # print all defined aliases
			if (keys (%aliases)) {
				foreach (keys %aliases) {
					print "$_\n";
				}
			}
			return 1;
		}

		my $key = shift @args;
		my $value = join(' ', @args);

		unless ($value) {
			return 10 unless $aliases{$key};
			print "$aliases{$key}\n";
			return 1;
		}

		if ($value eq '-') {
			delete($aliases{$key});
		} else {
			$aliases{$key} = $value;
		}
		$dirty = 1;

	} elsif ($command eq 'group') {
		unless ($args[0]) { # print all defined groups
			print join("\n", get_groups) . "\n";
			return 1;
		}

		my $key = shift @args;

		unless (@args) { # print all members of the group
			return 10 unless $groups{$key};
			foreach (@{$groups{$key}}) {
				print "$_\n";
			}
			return 1;
		}

		# check whether the specified user belongs to a group
		if (($#args == 0) && ($args[0] !~ /^(\+|-)/))
		{
			my $result = 10;
			return $result unless $groups{$key};
			foreach (@{$groups{$key}}) {
				$result = 1 if $_ eq $args[0];
			}
			return $result;
		}

		foreach (@args) { # check whether there is a syntax error
			return 0 unless ($_ =~ /^(\+|-)/);
		}

		foreach (@args) {
			my ($op, $member) = ($_ =~ /^(\+|-)([\w@._-]+)$/); # should we allow spaces here?
			my $found = 0;

			return 11 unless $member;

			# determine whether the member is already here
			# (and remove the member if it was requested)
			my $count = 0;
			foreach (@{$groups{$key}}) {
				if ($_ eq $member) {
					if ($op eq '-') {
						splice(@{$groups{$key}},$count,1);
						$found = 0;
						$dirty = 1;
					} else {
						$found = 1;
					}
				}
				$count++;
			}

			if ($op eq '+' && !$found) {
				push @{$groups{$key}},$member;
				$dirty = 1;
			}
		}

		return 2 if $dirty;

	} elsif ($command eq 'perms') {
		unless ($args[0]) { # print all defined objects
			print join("\n", get_objects()) . "\n";
			return 1;
		}

		my $object = shift @args;

		unless (@args) { # print all explicit perms for an object
			my $result = 10;
			return $result unless $paths{$object};
			$result = 1;
			foreach my $key ( sort perms keys %{$paths{$object}} ) {
				print "$key = " . ($paths{$object}{$key} ne 'none' ? $paths{$object}{$key} : '') . "\n"
			}
			return $result;
		}

		my $entity = shift @args;

		unless (@args) { # print all permissions on object for an entity
			my $result = 0;
			print get_permissions($object, $entity) . "\n";
			$result = 1;
			return $result;
		}

		my $perms = shift @args;
		unless ($perms =~ /^(r|rw|none|-)$/) {
			my $result = 0;
			# wrong permissions were provided
			return $result;
		}
		$perms = '' if $perms eq 'none';

		if ($perms eq '-') {
			delete $paths{$object}{$entity} if exists $paths{$object}{$entity};
		} else {
			$paths{$object}{$entity} = $perms;
		}
		$dirty = 1;

		my $options = shift @args if (@args);
		if (defined($options) && ($options =~ /^(r|recursive)$/i )) {
			my ($tmp_repo) = ($object =~ /^([\w-]+):/);
			$tmp_repo = '' unless (defined($tmp_repo));
			my $tmp_perms = get_permissions($object, $entity);
			$tmp_perms = '' unless(defined($tmp_perms));
			foreach (sort {$b cmp $a} get_objects())
			{
				my $tmp_object = $_;
				last if $tmp_object eq $object;
				$tmp_object =~ s/^[\w-]+:// unless $tmp_repo;

				if (index(($tmp_object eq '/' ? '' : $tmp_object) . '/', ($object eq '/' ? '' : $object) . '/', 0) == 0) {
					delete $paths{$_}{$entity} if exists $paths{$_}{$entity};
				}
			};
		}
	} elsif ($command eq 'user') {
		return 0 unless @args;
		my $user = shift @args;
		print join("\n", get_groups($user)) . "\n";
		return 1;
	} elsif ($command eq 'print') {
		write_authz;
		return 1;
	} else {
		usage();
	}

	return 2; # request the authz file update
}

unless (read_authz($authz_file))
{
	print "$0: error during reading authz file '$authz_file'!\n";
	exit 1;
}

my $result = process_command($action);

if ($result == 0)
{
	print "$0: error during processing the requested action!\n";
	exit 1;
}

exit $result if ($result > 9);

if ($result == 2) # need to update authz
{
	unless (write_authz($authz_file))
	{
		print "$0: error during writing authz file '$authz_file'!\n";
		exit 1;
	}
}

1;
